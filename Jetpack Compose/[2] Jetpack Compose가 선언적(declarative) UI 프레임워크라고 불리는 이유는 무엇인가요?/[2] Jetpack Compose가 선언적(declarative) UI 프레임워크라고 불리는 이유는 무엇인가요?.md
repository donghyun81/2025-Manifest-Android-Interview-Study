
### 1. 상태 주도 UI (State-Driven UI)

내장된 상태 관리 시스템 → 상태가 변할 때만 UI 자동 갱신.

개발자가 직접 View를 찾아서 값을 업데이트할 필요 없음.

기존의 LiveData/Observable 패턴과 유사하지만, 더 단순하고 일관적.

### 2. 함수/클래스로 정의되는 UI

UI는 @Composable 함수나 클래스 형태로 정의.

XML 같은 마크업 언어 불필요.

레이아웃과 동작을 모두 Kotlin/Java 같은 네이티브 언어에서 작성 가능.

장점

- XML을 관리하지 않아도 됨 → 코드 단일화.

- 함수 조합 기반 → 다른 함수와 결합해 모듈적이고 확장 가능한 구조 설계 가능.

### 3. 직접적인 데이터 바인딩 (Direct Data Binding)

상태(State)를 직접 UI에 반영.

별도의 데이터 바인딩 객체나 Adapter 패턴 없이 단순하게 데이터 표시 가능.

예: Text(name) → name만 바꾸면 UI 자동 업데이트.

### 4. 컴포넌트 멱등성 (Component Idempotence)

같은 입력 → 같은 출력 보장.

Recomposition 여러 번 발생해도 결과 일관성 유지.

테스트와 디버깅이 쉬워지고, 프레임워크가 최적화를 안전하게 적용 가능.

Jetpack Compose는 장기적으로 멀티스레드 기반 UI 생성을 지원하려 연구 중. 멱등성이 있기에 병렬 렌더링이 가능해지면 UI 작업 효율이 크게 향상될 수 있음.